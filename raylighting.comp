#version 460 core

layout (local_size_x = 30, local_size_y = 30, local_size_z = 1) in;

const int CHUNK_SIZE = 128;
const int CHUNK_HEIGHT = 128;
const int CHUNK_VOLUME = CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT;
const int CHUNKS_X = 8;
const int CHUNKS_Y = 1;
const int CHUNKS_Z = 8;
const int CHUNKS = CHUNKS_X*CHUNKS_Y*CHUNKS_Z;

uniform vec3 uSamples[64];

layout (binding = 0) buffer data
{
	int blocks[CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT * CHUNKS / 4 + CHUNKS];
};
layout (rgba32f, binding = 1) uniform image2D colInput;
layout (rgba32f, binding = 2) uniform image2D posInput;
layout (rgba32f, binding = 3) uniform image2D normHitInput;

layout (rgba32f, binding = 4) uniform image2D imgOutput;
layout (rgba32f, binding = 5) uniform image2D noiseTexture;
layout (rgba32f, binding = 6) uniform image2D ssaoTexture;

struct PointLight {    
    vec3 position;
    
    float constant;
    float linear;
    float quadratic;  

    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
};  

uniform vec2 uScreenSize;

uniform vec3 uCameraPosition;
uniform vec3 uCameraFront;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;

uniform float uDepth;
uniform bool uPBR;

uniform vec3 uChunkPosition;

uniform sampler2D tex;

uniform int uChunk[CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE];

#define RENDER_DISTANCE 400.0
#define N_LIGHTS 128

uniform float uXAngle;
uniform float uYAngle;
uniform float uZAngle;

uniform PointLight lights[N_LIGHTS];

int getChunkOffset(ivec3 chunk_pos)
{
    int chunkID = chunk_pos.x + chunk_pos.y * CHUNKS_X + chunk_pos.z * CHUNKS_Y * CHUNKS_Z;
    int intID = chunkID / 4;
    int localID = chunkID % 4;

    return (blocks[intID] >> (localID)*8) & 255;
}
int getVoxel(ivec3 voxelPos)
{
    if(voxelPos.y >= CHUNK_HEIGHT || voxelPos.y < 0)
        return 0;

    voxelPos = ivec3(voxelPos.x % (CHUNKS_X*CHUNK_SIZE), voxelPos.y % (CHUNKS_Y*CHUNK_HEIGHT), voxelPos.z % (CHUNKS_Z*CHUNK_SIZE));


    ivec3 chunk_pos = ivec3(voxelPos.x / CHUNK_SIZE, voxelPos.y / CHUNK_HEIGHT, voxelPos.z / CHUNK_SIZE);
    int chunk_offset = getChunkOffset(chunk_pos);
    if(chunk_offset == -1)
        return 0;

    ivec3 localPos = ivec3(voxelPos.x % CHUNK_SIZE, voxelPos.y % CHUNK_HEIGHT, voxelPos.z % CHUNK_SIZE);

	int i = localPos.x + localPos.y * CHUNK_SIZE + localPos.z * CHUNK_HEIGHT * CHUNK_SIZE;

    if(i >= CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT * CHUNKS + CHUNKS || i < 0)
        return 0;

    int chunkID = i + CHUNKS + chunk_offset*CHUNK_VOLUME;
    
    int intID = chunkID / 4;
    int localID = chunkID % 4;
    
    return (blocks[intID] >> (localID)*8) & 255;
}


bool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d, int ignore) {

    float maxdist = length(rd);
    
    rd /= maxdist;
    
    float ty = CHUNK_HEIGHT/rd.y - ro.y/rd.y;
    float t = 0;
    
    d = 0.0;
    if(ro.y > CHUNK_HEIGHT)
    {
        
        vec3 new = ro + rd * ty;
        
        t = ty;
        ro = new;
    }

    pos = ivec3(floor(ro));
    ivec3 ppos = pos;

    vec3 s = sign(rd);
    ivec3 is = ivec3(s);

    vec3 td = s / rd;

    if(isnan(td.x) || isinf(td.x)) td.x = 1e10;
    if(isnan(td.y) || isinf(td.y)) td.y = 1e10;
    if(isnan(td.z) || isinf(td.z)) td.z = 1e10;
    
    vec3 tm;
    
    if(s.x > 0.0) tm.x = td.x * ((1.0 - ro.x) + floor(ro.x)); else tm.x = td.x * fract(ro.x);
    if(s.y > 0.0) tm.y = td.y * ((1.0 - ro.y) + floor(ro.y)); else tm.y = td.y * fract(ro.y);
    if(s.z > 0.0) tm.z = td.z * ((1.0 - ro.z) + floor(ro.z)); else tm.z = td.z * fract(ro.z);


    while(true) {
        if(d > maxdist) break;

        index = getVoxel(pos);
        
        if(pos.y > CHUNK_HEIGHT && rd.y > 0)
        {
            pos = ivec3(floor(ro));
            nor = ivec3(0, 0, 0);
            index = 0;
            d = maxdist;
            return false;
        }

        if(index != ignore) {
            nor = ppos - pos;
            return true;
        }

        ppos = pos;
    
        if(tm.x < tm.y) {
            if(tm.x < tm.z) {
                d = tm.x + t;
                pos.x += is.x;
                tm.x += td.x;
            }
            else {
                d = tm.z + t;
                pos.z += is.z;
                tm.z += td.z;
            }
        }
        else {
            if(tm.y < tm.z) {
                d = tm.y + t;
                pos.y += is.y;
                tm.y += td.y;
            }
            else {
                d = tm.z + t;
                pos.z += is.z;
                tm.z += td.z;
            }
        }
    }
    pos = ivec3(floor(ro));
    nor = ivec3(0, 0, 0);
    index = 0;
    d = maxdist;
    return false;
}

bool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d) {
    return raycastVoxel(ro, rd, pos, nor, index, d, 0);
}


#define PI 3.14159265359

float ggx_distribution(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = max(PI * denom * denom, 0.001);
	
    return num / denom;
}

float ggx_geometry_schlick(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = max(NdotV * (1.0 - k) + k, 0.001);
	
    return num / denom;
}
float smith_geometry(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = ggx_geometry_schlick(NdotV, roughness);
    float ggx1  = ggx_geometry_schlick(NdotL, roughness);
	
    return ggx1 * ggx2;
}

vec3 fresnel_schlick(float cos_theta, vec3 F0)
{
    return (F0 + (1.0 - F0) * pow(clamp(1.0 - cos_theta, 0.0, 1.0), 5.0));
}  

struct Material
{
	vec3 albedo;
	float metallic;
	float roughness;
	float ao;
};
vec3 calc_dir_light(Material material, vec3 normal, vec3 cam_pos, vec3 world_pos, vec3 light_dir)
{
	normal = normalize(normal);
	vec3 view_dir = normalize(cam_pos - world_pos);

	vec3 F0 = vec3(0.04);
	F0 = mix(F0, material.albedo, material.metallic);

	vec3 Lo = vec3(0.0);
    vec3 skyColor = vec3(0.3333, 0.69019607843, 1.0) * clamp((uYAngle + 0.2), 0.0, 1.0);


	vec3 light_color = vec3(2.0);

		vec3 halfway = normalize(view_dir + light_dir);

		vec3 radiance = light_color;


		float NDF = ggx_distribution(normal, halfway, material.roughness);
		float G   = smith_geometry(normal, view_dir, light_dir, material.roughness);
		vec3 F = fresnel_schlick(max(dot(halfway, view_dir), 0.0), F0);

		float nl = max(dot(normal, light_dir), 0.0);

		vec3 kS = F;
		vec3 kD = vec3(1.0) - kS;
		kD *= 1.0 - material.metallic;

		vec3 numerator = NDF * G * F;
		float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * nl + 0.0001;
		vec3 specular = numerator / denominator;

		Lo += (kD * material.albedo / PI + specular) * radiance * nl;

	vec3 ambient = skyColor * vec3(0.2) * material.albedo * material.ao;
    

    ivec3 shadow_vp, shadow_vn; int shadow_index; float shadow_d;
    bool shadow_hit = raycastVoxel(world_pos + (normal * 0.001), light_dir * 100.0, shadow_vp, shadow_vn, shadow_index, shadow_d);

	float shadow = shadow_hit ? 0.0 : 1.0;
    
	vec3 color = ambient + Lo * shadow * material.ao;
	return color;
}


vec3 CalcDirLight(vec3 point, vec3 normal, vec3 textureColor, float occlusion1, float sp, out vec3 specular)
{
    vec3 worldUp = vec3(0,1,0);

    vec3 lightDir = normalize(vec3(uXAngle, uYAngle, uZAngle));
	
	vec3 viewDir = normalize(uCameraPosition - point);
    
    vec3 skyColor = vec3(1.0);//vec3(0.3333, 0.69019607843, 1.0) * clamp((uYAngle + 0.2), 0.0, 1.0);
	vec3 ambientCol = skyColor * occlusion1 * (clamp((uYAngle), -0.6, 0.2) + 0.625) * 0.5;
	vec3 diffuseCol = vec3(1.0) * occlusion1;
	vec3 specularCol = vec3(1.0);
	
    ambientCol += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(uYAngle), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(lightDir, lightDir) + 1, 0.0, 2.0) * 0.5, 2) * 0.05;
    diffuseCol += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(uYAngle), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(lightDir, lightDir) + 1, 0.0, 2.0) * 0.5, 2) * 0.05;

    vec3 halfwayDir = normalize(lightDir + viewDir);
    
    float diff = max(dot(normal, lightDir), 0.0);
    
    //vec3 reflectDir = reflect(-lightDir, normal);
    
    float shininess = 32.0;

    float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess*2);

    

    
    vec3 ambient = ambientCol * textureColor;// *0.4*(normal*0.5+0.5).y;
    vec3 diffuse = diffuseCol   * diff * textureColor;
    specular = specularCol * spec * sp;
	

    ivec3 shadow_vp, shadow_vn; int shadow_index; float shadow_d;
    bool shadow_hit = raycastVoxel(point + (normal * 0.001), lightDir * 100.0, shadow_vp, shadow_vn, shadow_index, shadow_d);

	float shadow = shadow_hit ? 0.0 : 1.0;
	vec3 result = ambient + (shadow) * (diffuse + specular);
    return result;
}


vec2 getTexCoord(vec3 point, ivec3 normal)
{
	vec3 facePos = fract(point);
	
	if(normal.x < 0)
	{
		return facePos.zy;
	}
	else if(normal.x > 0)
	{
		return vec2(1-facePos.z, facePos.y);
	}
	else if(normal.y > 0)
	{
		return vec2(1-facePos.x, facePos.z);
	}
	else if(normal.y < 0)
	{
		return facePos.xz;
	}
	if(normal.z > 0)
	{
		return facePos.xy;
	}
	else if(normal.z < 0)
	{
		return vec2(1-facePos.x, facePos.y);
	}
	return vec2(0);
}

void main()
{
	// Pixel position in screen space, x = [-1, 1], y = [-1, 1]
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 screenPos = (texelCoord / uScreenSize) * 2 - 1;
	
    
    vec4 color = imageLoad(colInput, texelCoord);
    vec4 dirDist = imageLoad(posInput, texelCoord);
    vec4 normHit = imageLoad(normHitInput, texelCoord);
    vec3 randomVec = imageLoad(noiseTexture, ivec2(texelCoord / 4.0) % 4).xyz;
    float ssao = imageLoad(ssaoTexture, texelCoord).x;

    vec3 dir = dirDist.xyz;
    float dist = dirDist.w;
    
    vec3 pos = uCameraPosition + dir * dist;

    vec3 tangent   = normalize(randomVec - normHit.xyz * dot(randomVec, normHit.xyz));
    vec3 bitangent = cross(normHit.xyz, tangent);
    mat3 TBN       = mat3(tangent, bitangent, normHit.xyz); 
    
    vec3 filmCentre = uCameraPosition + uCameraFront*1.0;
    vec2 filmSize = vec2(1, uScreenSize.y / uScreenSize.x);
    
    //vec3 filmPos = filmCentre + screenPos.x*filmSize.x*uCameraRight + screenPos.y*filmSize.y*uCameraUp;
    
    vec3 filmMax = uCameraFront*1.0 + filmSize.x*uCameraRight + filmSize.y*uCameraUp;

    float result1 = 0.0;
    int xSize = 2;
    int ySize = 2;

    

    for (int x = -xSize; x < xSize; ++x) 
    {
        for (int y = -ySize; y < ySize; ++y) 
        {
            ivec2 offset = ivec2(x, y);
            result1 += imageLoad(ssaoTexture, texelCoord + ivec2(x, y)).r;
        }
    }
    //float val = pow(2,((dot(normalize(dir), normalize(vec3(uXAngle, uYAngle, uZAngle))) + 1) * 0.5));

	//vec3 skyColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0);
	//outputColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0);

    
    vec3 lightDir = normalize(vec3(uXAngle, uYAngle, uZAngle));
    float val = pow(2,((dot(dir, lightDir) + 1) * 0.5));


    // Blue sky
	vec3 skyColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0) * 1.2;

    // Red glow during mornings and evenings
    skyColor += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(dir.y), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(dir, lightDir) + 1, 0.0, 2.0) * 0.5, 2);
       
    // Sun
    //skyColor += vec3(clamp(pow(dot(dir, lightDir), 1000), 0.0, 1.0));

    Material mat = {color.xyz, color.w > 0.5 ? 0.0 : 0.0, color.w > 0.5 ? 0.2 : 1.0, result1 / (xSize * 2.0 * ySize * 2.0)};

    if(normHit.w > 0.2)
    {
        float factor = dist / RENDER_DISTANCE;
        factor = pow(factor, 10);
        factor = clamp(factor, 0.0, 1.0);
        vec3 specular;
        if(uPBR)
            color.xyz = calc_dir_light(mat, normHit.xyz, uCameraPosition, pos.xyz, lightDir);
        else
            color.xyz = CalcDirLight(pos.xyz, normHit.xyz, color.xyz, result1 / (xSize * 2.0 * ySize * 2.0), color.w, specular);
        color.xyz = color.xyz * (1.0 - factor) + skyColor * factor;
    }
    imageStore(imgOutput, texelCoord, vec4(color.xyz, 1.0));
    

    
}

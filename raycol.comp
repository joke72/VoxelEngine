#version 460 core

layout (local_size_x = 30, local_size_y = 30, local_size_z = 1) in;

uniform vec2 uScreenSize;

uniform vec3 uCameraPosition;
uniform vec3 uCameraFront;
uniform vec3 uCameraRight;
uniform vec3 uCameraUp;

uniform float uXAngle;
uniform float uYAngle;
uniform float uZAngle;

const int CHUNK_SIZE = 128;
const int CHUNK_HEIGHT = 128;
const int CHUNK_VOLUME = CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT;
const int CHUNKS_X = 8;
const int CHUNKS_Y = 1;
const int CHUNKS_Z = 8;
const int CHUNKS = CHUNKS_X*CHUNKS_Y*CHUNKS_Z;

uniform sampler2D tex;

#define RENDER_DISTANCE 400.0


layout (binding = 0) buffer data
{
	int blocks[CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT * CHUNKS/4 + CHUNKS];
};
layout (rgba32f, binding = 1) uniform image2D colOutput;
layout (rgba32f, binding = 2) uniform image2D posOutput;
layout (rgba32f, binding = 3) uniform image2D normHitOutput;
layout (rgba32f, binding = 4) uniform image2D imgOutput;

int getChunkOffset(ivec3 chunk_pos)
{
    int chunkID = chunk_pos.x + chunk_pos.y * CHUNKS_X + chunk_pos.z * CHUNKS_Y * CHUNKS_Z;
    int intID = chunkID / 4;
    int localID = chunkID % 4;

    return (blocks[intID] >> (localID)*8) & 255;
}
/*
int getVoxel(ivec3 voxelPos)
{
    ivec3 chunk_pos = voxelPos / CHUNK_SIZE;
    int chunk_offset = getChunkOffset(chunk_pos);
    

	int i = voxelPos.x + voxelPos.y * CHUNK_SIZE + voxelPos.z * CHUNK_HEIGHT * CHUNK_SIZE;
	if(voxelPos.x < 0 || voxelPos.x >= CHUNK_SIZE || voxelPos.y < 0 || voxelPos.y >= CHUNK_HEIGHT || voxelPos.z < 0 || voxelPos.z >= CHUNK_SIZE)
		return 0;
	return blocks[i + CHUNKS];
}
*/
int getVoxel(ivec3 voxelPos)
{
    if(voxelPos.y >= CHUNK_HEIGHT || voxelPos.y < 0)
        return 0;

    voxelPos = ivec3(voxelPos.x % (CHUNKS_X*CHUNK_SIZE), voxelPos.y % (CHUNKS_Y*CHUNK_HEIGHT), voxelPos.z % (CHUNKS_Z*CHUNK_SIZE));


    ivec3 chunk_pos = ivec3(voxelPos.x / CHUNK_SIZE, voxelPos.y / CHUNK_HEIGHT, voxelPos.z / CHUNK_SIZE);
    int chunk_offset = getChunkOffset(chunk_pos);
    if(chunk_offset == -1)
        return 0;

    ivec3 localPos = ivec3(voxelPos.x % CHUNK_SIZE, voxelPos.y % CHUNK_HEIGHT, voxelPos.z % CHUNK_SIZE);

	int i = localPos.x + localPos.y * CHUNK_SIZE + localPos.z * CHUNK_HEIGHT * CHUNK_SIZE;

    if(i >= CHUNK_SIZE * CHUNK_SIZE * CHUNK_HEIGHT * CHUNKS + CHUNKS || i < 0)
        return 0;

    int chunkID = i + CHUNKS + chunk_offset*CHUNK_VOLUME;
    
    int intID = chunkID / 4;
    int localID = chunkID % 4;
    
    return (blocks[intID] >> (localID)*8) & 255;
}


bool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d, int ignore) {

    float maxdist = length(rd);
    
    rd /= maxdist;
    
    float ty = CHUNK_HEIGHT/rd.y - ro.y/rd.y;
    float t = 0;
    
    d = 0.0;
    if(ro.y > CHUNK_HEIGHT)
    {
        
        vec3 new = ro + rd * ty;
        
        t = ty;
        ro = new;
    }

    pos = ivec3(floor(ro));
    ivec3 ppos = pos;

    vec3 s = sign(rd);
    ivec3 is = ivec3(s);

    vec3 td = s / rd;

    if(isnan(td.x) || isinf(td.x)) td.x = 1e10;
    if(isnan(td.y) || isinf(td.y)) td.y = 1e10;
    if(isnan(td.z) || isinf(td.z)) td.z = 1e10;
    
    vec3 tm;
    
    if(s.x > 0.0) tm.x = td.x * ((1.0 - ro.x) + floor(ro.x)); else tm.x = td.x * fract(ro.x);
    if(s.y > 0.0) tm.y = td.y * ((1.0 - ro.y) + floor(ro.y)); else tm.y = td.y * fract(ro.y);
    if(s.z > 0.0) tm.z = td.z * ((1.0 - ro.z) + floor(ro.z)); else tm.z = td.z * fract(ro.z);


    while(true) {
        if(d > maxdist) break;

        index = getVoxel(pos);
        
        if(pos.y > CHUNK_HEIGHT && rd.y > 0)
        {
            pos = ivec3(floor(ro));
            nor = ivec3(0, 0, 0);
            index = 0;
            d = maxdist;
            return false;
        }

        if(index != ignore) {
            nor = ppos - pos;
            return true;
        }

        ppos = pos;
    
        if(tm.x < tm.y) {
            if(tm.x < tm.z) {
                d = tm.x + t;
                pos.x += is.x;
                tm.x += td.x;
            }
            else {
                d = tm.z + t;
                pos.z += is.z;
                tm.z += td.z;
            }
        }
        else {
            if(tm.y < tm.z) {
                d = tm.y + t;
                pos.y += is.y;
                tm.y += td.y;
            }
            else {
                d = tm.z + t;
                pos.z += is.z;
                tm.z += td.z;
            }
        }
    }
    pos = ivec3(floor(ro));
    nor = ivec3(0, 0, 0);
    index = 0;
    d = maxdist;
    return false;
}

bool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d) {
    return raycastVoxel(ro, rd, pos, nor, index, d, 0);
}

vec2 getTexCoord(vec3 point, ivec3 normal)
{
	vec3 facePos = fract(point);
	
	if(normal.x < 0)
	{
		return facePos.zy;
	}
	else if(normal.x > 0)
	{
		return vec2(1-facePos.z, facePos.y);
	}
	else if(normal.y > 0)
	{
		return vec2(1-facePos.x, facePos.z);
	}
	else if(normal.y < 0)
	{
		return facePos.xz;
	}
	if(normal.z > 0)
	{
		return facePos.xy;
	}
	else if(normal.z < 0)
	{
		return vec2(1-facePos.x, facePos.y);
	}
	return vec2(0);
}
void main()
{
	// Pixel position in screen space, x = [-1, 1], y = [-1, 1]
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
	vec2 screenPos = (texelCoord / uScreenSize) * 2 - 1;
	
    vec3 filmCentre = uCameraPosition + uCameraFront*1.0;
    vec2 filmSize = vec2(1, uScreenSize.y / uScreenSize.x);
    
    vec3 filmPos = filmCentre + screenPos.x * filmSize.x * uCameraRight + screenPos.y * filmSize.y * uCameraUp;
    vec3 rayDirection = normalize(filmPos - uCameraPosition);
		
	ivec3 oPos;
	ivec3 oNor;
	int oIndex;
	float oDist;

	bool wasHit = raycastVoxel(uCameraPosition, rayDirection * RENDER_DISTANCE, oPos, oNor, oIndex, oDist);
	vec4 color = vec4(0);
    
    vec4 color0 = vec4(0.2, 0.4, 0.6, 1.0);
    vec4 color1 = vec4(0.5, 0.1, 0.2, 1.0);
    
    vec3 pos = uCameraPosition + rayDirection * oDist;

    int hit = wasHit ? 1 : 0;
    
	vec3 outputColor;
     
    bool wasHit2;

    if(!wasHit)
    {
        vec3 lightDir = normalize(vec3(uXAngle, uYAngle, uZAngle));
        float val = pow(2,((dot(rayDirection, lightDir) + 1) * 0.5));


        // Blue sky
	    outputColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0) * 1.2;

        // Red glow during mornings and evenings
        outputColor += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(rayDirection.y), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(rayDirection, lightDir) + 1, 0.0, 2.0) * 0.5, 2);
       
        // Sun
        outputColor += vec3(clamp(pow(dot(rayDirection, lightDir), 1000), 0.0, 1.0));
    }
    else {
	    vec2 texCoords = getTexCoord(pos, oNor);
    
	    vec2 yOffset = vec2(0.0, 15.0);
	    vec2 texturePos = vec2((oIndex-1) % 16, -(oIndex-1) / 16);
	    vec2 tilesInTexture = vec2(16, 16);

        outputColor = vec3(texture(tex, (((texCoords) + yOffset + texturePos) / tilesInTexture)));

        if(oIndex == 3)
        {
            vec3 newDir = normalize(reflect(rayDirection, vec3(oNor)));
        
            vec3 lightDir = normalize(vec3(uXAngle, uYAngle, uZAngle));
            float val = pow(2,((dot(newDir, lightDir) + 1) * 0.5));


            // Blue sky
	        outputColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0) * 1.2;

            // Red glow during mornings and evenings
            outputColor += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(newDir.y), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(newDir, lightDir) + 1, 0.0, 2.0) * 0.5, 2);
       
            // Sun
            outputColor += vec3(clamp(pow(dot(newDir, lightDir), 1000), 0.0, 1.0));
        }

        /*
        if(oIndex == 3)
        {

            vec3 newStart = pos + oNor * 0.01;
            vec3 newDir = reflect(rayDirection, vec3(oNor));

            float garbage;

	        wasHit2 = raycastVoxel(newStart, newDir * RENDER_DISTANCE, oPos, oNor, oIndex, oDist);
            
            if(!wasHit2)
            {
    
                float val = pow(2,((dot(normalize(newDir), normalize(vec3(uXAngle, uYAngle, uZAngle))) + 1) * 0.5));


                vec3 lightDir = normalize(vec3(uXAngle, uYAngle, uZAngle));

                // Blue sky
	            outputColor = vec3(val * 0.3333, val * 0.69019607843, val) * clamp((uYAngle + 0.2), 0.0, 1.0) * 1.2;

                // Red glow during mornings and evenings
                outputColor += pow((1.0 - abs(uYAngle)), 5.0) * clamp(pow(1.0 - abs(newDir.y), 5), 0.0, 1.0) * 2.0 * vec3(1.0, 0.0 , -0.5) * pow(clamp(dot(newDir, lightDir) + 1, 0.0, 2.0) * 0.5, 2);
       
                // Sun
                outputColor += vec3(clamp(pow(dot(newDir, lightDir), 1000), 0.0, 1.0));
            }
            else
            {
                vec3 newPos = newStart + newDir * oDist;
        
                vec2 texCoords = getTexCoord(newPos, oNor);
    
	            vec2 yOffset = vec2(0.0, 15.0);
	            vec2 texturePos = vec2((oIndex-1) % 16, -(oIndex-1) / 16);
	            vec2 tilesInTexture = vec2(16, 16);

                outputColor = vec3(texture(tex, (((texCoords) + yOffset + texturePos) / tilesInTexture)));
            }
        
        }
            
            */

    }

    
    
	imageStore(colOutput, texelCoord, vec4(outputColor, (oIndex == 3 || oIndex == (3 + 16)) ? 1.0 : 0.0));
	imageStore(imgOutput, texelCoord, vec4(outputColor, (oIndex == 3 || oIndex == (3 + 16)) ? 1.0 : 0.0));
	imageStore(posOutput, texelCoord, vec4(rayDirection, oDist));
	imageStore(normHitOutput, texelCoord, vec4(oNor, wasHit ? 1.0 : 0.0));


    /*
	imageStore(colOutput, texelCoord, color);
	imageStore(posOutput, texelCoord, vec4(pos, 1));
	imageStore(normOutput, texelCoord, vec4(oNor, 1));*/


}
